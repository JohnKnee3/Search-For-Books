# 21.1.3

Set up the base files from the module. Ran npm i and npm run seed. May need to go back and run mongod if the seed didn't run properly. At a glance in the console.log it looks like it did.

# 21.1.4

We set up our first query. We essentially learned that GraphQL calls all GETs query and all PUT, POST, and DELETEs mutations. We created a new folder called schema and added the index.js like this.

const typeDefs = require("./typeDefs");
const resolvers = require("./resolvers");

module.exports = { typeDefs, resolvers };

To require the first file we need called typeDefs like this.

// import the gql tagged template function
const { gql } = require("apollo-server-express");

// create our typeDefs
const typeDefs = gql` type Query { helloWorld: String }`;
// export the typeDefs
module.exports = typeDefs;

This defines what we are looking for and where we can find it. Then we set up the resolvers to preform this like this.

const resolvers = {
Query: {
helloWorld: () => {
return "Hello world!";
},
},
};

module.exports = resolvers;

Here we are running the helloWrold() called in the type Query object and returning a string that says "Hello World". Then we went into server.js and added a ton of things that basically required graphQL apollo to run. Lastly we ran npm run watch to fire the package.json script that takes us to a browser that looks like GraphQL's version of insomnia and tested the the query.

# 21.1.5

Here we did our first test to grab all thoughts like this in typeDef.

type Thought {
\_id: ID
thoughtText: String
createdAt: String
username: String
reactionCount: Int
}

type Query {
thoughts: [Thought]
}

This creates the thoughts array and then defins what it will grab. The we slid into resolvers.js and added this.

const resolvers = {
Query: {
thoughts: async () => {
return Thought.find().sort({ createdAt: -1 });
}
}
};

Which perfoms a find query to grab all thoughts and sorts them by created at. Up top we required the models and then juped into the graphql browser. In there we typed this..

query {
thoughts {
\_id
username
thoughtText
createdAt
}
}

This went through thoughts and grabbed everyting we defined in the object. Also we can remove or add anything from lines 43-47 to change what is shown because that is where we dfined them. Next we brought in the ability to search by user by passing in a parameter into the thoughts typeDef like this.

type Query {
thoughts(username: String): [Thought]
}

and then went into the resolver.js to use it here like this.

thoughts: async (parent, { username }) => {
const params = username ? { username } : {};
return Thought.find(params).sort({ createdAt: -1 });
},

This is saying if username then params = {username} else params = {}. This makes it so we can sort by indvidual user by going into the graphql browser and typing this.

query {
thoughts (username: "Domenica.OConnell") {
\_id
username
thoughtText
createdAt
}
}

Domenica.OConnell is a random user generated by the program. Lastly we added the ability to grab reaction by simply adding this to typeDef.

const typeDefs = gql`

type Thought {
\_id: ID
thoughtText: String
createdAt: String
username: String
reactionCount: Int
reactions: [Reaction]
}

type Reaction {
\_id: ID
reactionBody: String
createdAt: String
username: String
}

type Query {
thoughts(username: String): [Thought]
}
`;

Then we went back into the graphql browser and added this to grab all reactions and thoughts.

query {
thoughts {
\_id
username
thoughtText
reactions {
\_id
createdAt
username
reactionBody
}
}
}

# 21.1.6

Here we quickly added the new User type and updated the query to search by all users and one user and all thoughts and one thought like this.

type Query {
users: [User]
user(username: String!): User
thoughts(username: String): [Thought]
thought(\_id: ID!): Thought
}

type User {
\_id: ID
username: String
email: String
friendCount: Int
thoughts: [Thought]
friends: [User]
}

The rest was testing the querys and basically setting up mega querys to grab everthing and then collapsing the data to parse through what you want all in graphql. The last thing we did was practice sending in a variable through graphQL as well. I saved both of these moving forward as I think they will remain useful. There is a ton of data here so coming back reading this may be helpful in terms of understandin graphQL.

# 21.2.3

We added the ability for a user to create an account and log in. First in typeDefs.js we added this to accept mutations.

type Mutation {
login(email: String!, password: String!): User
addUser(username: String!, email: String!, password: String!): User
}

Then we went into resolvers.s and added this to create the ability to make a user.

addUser: async (parent, args) => {
const user = await User.create(args);

return user;
}

This accepts the username, password and email and uses this info to make an account. Then in graphQL we added this.

mutation {
addUser(username:"tester", password:"test12345", email:"test@test.com") {
\_id
username
email
}
}

Then we switched it to variables.

mutation addUser($username: String!, $password: String!, $email: String!) {
addUser(username: $username, password: $password, email: $email) {
\_id
username
email
}
}

and passed in this.

{
"username": "tester2",
"password": "test12345",
"email": "test2@test.com"
}

Both of these created users just the second one is closer to what it will acutally look like once we have the front end hooked up. Finally up top we added this.

const { AuthenticationError } = require('apollo-server-express');

and then this in the login section.

login: async (parent, { email, password }) => {
const user = await User.findOne({ email });

if (!user) {
throw new AuthenticationError('Incorrect credentials');
}

const correctPw = await user.isCorrectPassword(password);

if (!correctPw) {
throw new AuthenticationError('Incorrect credentials');
}

return user;
}

to make sure we get tossed an error if the log in was not valid. Then using variables we went into graphQL and used.

mutation login($email: String!, $password: String!) {
login(email: $email, password: $password) {
\_id
username
email
}
}

and this

{
"email": "test2@test.com",
"password": "test12345"
}

to log in as an existing user.

# 21.2.4 & 21.2.5

Here we learned about authentication. This was fairly confusing but the main thing that tripped me up was the header. Make sure moving forward that the key is "Authorization" and the Value is "Bearer <insert token here>". The bearer bit was the part i missed. All of this is worth another read when it comes time to do the project.

# 21.2.6

A really insteresting one that added the ability to add thoughts, reactions and friends. First we went into the typeDefs.js and added this to the mutation.

type Mutation {
login(email: String!, password: String!): Auth
addUser(username: String!, email: String!, password: String!): Auth
addThought(thoughtText: String!): Thought
addReaction(thoughtId: ID!, reactionBody: String!): Thought
addFriend(friendId: ID!): User
}

Then we went into the resolvers and added the ability to add a thought like this.

addThought: async (parent, args, context) => {
if (context.user) {
const thought = await Thought.create({
...args,
username: context.user.username,
});

        await User.findByIdAndUpdate(
          { _id: context.user._id },
          { $push: { thoughts: thought._id } },
          { new: true }
        );

        return thought;
      }

      throw new AuthenticationError("You need to be logged in!");
    },

      This for this in graphQL we added this.

      mutation addThought($thoughtText: String!) {

addThought(thoughtText: $thoughtText) {
\_id
thoughtText
createdAt
username
reactionCount
}
}

with the thoughtText variable passed in to modify the text making sure we were logged in via the header. Then we added a reaction by passing this into resolvers.js.

addReaction: async (parent, { thoughtId, reactionBody }, context) => {
if (context.user) {
const updatedThought = await Thought.findOneAndUpdate(
{ \_id: thoughtId },
{
$push: {
reactions: { reactionBody, username: context.user.username },
},
},
{ new: true, runValidators: true }
);

        return updatedThought;
      }

      throw new AuthenticationError("You need to be logged in!");
    },

Then we went into the graphQL and added this.

    mutation addReaction($thoughtId: ID!, $reactionBody: String!) {

addReaction(thoughtId: $thoughtId, reactionBody: $reactionBody) {
\_id
reactionCount
reactions {
\_id
reactionBody
createdAt
username
}
}
}

We passed in a thoughtId which I had to look up to find a real one and then typed whatever we wanted into the reactionBody. Finally again since this is using context we had to make sure the header passed in an active token like before. Lastly we created the ability to add a friend like this in resolvers.js.

addFriend: async (parent, { friendId }, context) => {
if (context.user) {
const updatedUser = await User.findOneAndUpdate(
{ \_id: context.user.\_id },
{ $addToSet: { friends: friendId } },
{ new: true }
).populate("friends");

        return updatedUser;
      }

      throw new AuthenticationError("You need to be logged in!");
    },

Then we had to look up a vild user name and pass that in to this.

mutation addFriend($friendId: ID!) {
addFriend(friendId: $friendId) {
\_id
username
friendCount
friends {
\_id
username
}
}
}

So the friendId could have a valid ud tied to a username. Once again since this has context in it we had to make sure the header matched an active token tied to an id.

# 21.3.3

Got all the basic files in for react. We removed the package-lock.json right now which I found funny beacuase they claimed it will cause problems. I assume it will make it's way back once we get going.

# 21.3.4

Here we set up the app.js to include apollo. First we navigated to the root of client and ran this.

npm i @apollo/client graphql

Which installed the apollo/client and graphql. Then we went into the app and imported appllo like this.

import { ApolloProvider, ApolloClient, InMemoryCache, createHttpLink } from '@apollo/client';

Next we added an absolute path to our backend and created the variable client to create a new intance of the ApolloClient and the MemoryCache like this.

const httpLink = createHttpLink({
uri: 'http://localhost:3001/graphql',
});

const client = new ApolloClient({
link: httpLink,
cache: new InMemoryCache(),
});

Finally in the JSX return statement we wrapped everthing that was there in a <ApolloProvider client={client}></ApolloProvider> like this.

function App() {
return (
<ApolloProvider client={client}>

<div className="flex-column justify-flex-start min-100-vh">
<Header />
<div className="container">
<Home />
</div>
<Footer />
</div>
</ApolloProvider>
);
}

We are now about to set up a query to see if this works.

# 21.3.5

Here we linked the thoughts data from the database to the actual page. First in the client/src folder we created a utils folder and added queries.js. In this we added our first QUERY_THOUGHTS query to the program and exported it like this.

import { gql } from '@apollo/client';

export const QUERY_THOUGHTS = gql` query thoughts($username: String) { thoughts(username: $username) { _id thoughtText createdAt username reactionCount reactions { _id createdAt username reactionBody } } }`;

We aslo had to import and then wrap the entire query in the gql variable. Next we went into Home.js and required uesQuery and the newly created QUERY_THOUGHTS up top and then updated the Home() to look like this.

import { useQuery } from '@apollo/client';
import { QUERY_THOUGHTS } from '../utils/queries';

const Home = () => {
// use useQuery hook to make query request
const { loading, data } = useQuery(QUERY_THOUGHTS);
const thoughts = data?.thoughts || [];
console.log(thoughts);

return (

<main>
<div className='flex-row justify-space-between'>
<div className='col-12 mb-3'>{/_ PRINT THOUGHT LIST _/}</div>
</div>
</main>
);
};

We also had to toss in this data?.thoughts || [] to say if data is real then add it if not send back an empty array. Next we fired up the backend from the server terminal with `npm run watch` and the client terminal with `npm start`. Checking the console we see an empty array as we are waiting for the data to appear and then a populated array once the data is retreived from the back-end. Finally we went into the components and created a way to display this info with a file called ThougtList. In this we added this.

import React from "react";

const ThoughtList = ({ thoughts, title }) => {
if (!thoughts.length) {
return <h3>No Thoughts Yet</h3>;
}

return (

<div>
<h3>{title}</h3>
{thoughts &&
thoughts.map((thought) => (
<div key={thought._id} className="card mb-3">
<p className="card-header">
{thought.username}
thought on {thought.createdAt}
</p>
<div className="card-body">
<p>{thought.thoughtText}</p>
<p className="mb-0">
Reactions: {thought.reactionCount} || Click to{" "}
{thought.reactionCount ? "see" : "start"} the discussion!
</p>
</div>
</div>
))}
</div>
);
};

export default ThoughtList;

Which was nothing more than a copy paste to get things displayed. Then we went back into the Home.js and required this new folder up top and it to the like this.

import React from "react";
import ThoughtList from "../components/ThoughtList";
import { useQuery } from "@apollo/client";
import { QUERY_THOUGHTS } from "../utils/queries";

const Home = () => {
// use useQuery hook to make query request
const { loading, data } = useQuery(QUERY_THOUGHTS);
const thoughts = data?.thoughts || [];
console.log(thoughts);

return (

<main>
<div className="flex-row justify-space-between">
<div className="col-12 mb-3">
{loading ? (
<div>Loading...</div>
) : (
<ThoughtList
              thoughts={thoughts}
              title="Some Feed for Thought(s)..."
            />
)}
</div>
</div>
</main>
);
};

export default Home;

Once all this is in the site displays. Next they claim we are going to remove the need to have 2 terminals running to make this page work.

# 21.3.6

set up the files to run on one terminal command by creating a root package.json installing concurrently and then setting up as few other things. This will be needed for the future to be able to set up all my react files.

# 21.4.3

Just discovered the client/package.json will break the module. Need to update the package.json to "react-router-dom": "^6.0.0",. But anyways this introduced ReactRouter which makes a SPA act like a multipage document. First we installed react-router with this `npm install react-router-dom` in the terminal and then we went into our app.js and imported it up top like this.

import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

Next we imported links to all our other files that will be loaded when selected like this.

import Login from './pages/Login';
import NoMatch from './pages/NoMatch';
import SingleThought from './pages/SingleThought';
import Profile from './pages/Profile';
import Signup from './pages/Signup';

Finally we updtaed the app() to look like this.

function App() {
return (
<ApolloProvider client={client}>
<Router>

<div className="flex-column justify-flex-start min-100-vh">
<Header />
<div className="container">
<Routes>
<Route path="/" element={<Home />} />
<Route path="/login" element={<Login />} />
<Route path="/signup" element={<Signup />} />
<Route path="/profile" element={<Profile />} />
<Route path="/thought" element={<SingleThought />} />

              <Route path="*" element={<NoMatch />} />
            </Routes>
          </div>
          <Footer />
        </div>
      </Router>
    </ApolloProvider>

);
}

Here we have several nested <Route>'s that will trigger the imported path when selected. These are all nested within <Routes> which is inside of <Router> which are all of the variables we imported up top. As is stands right now we can click on a page and be redirectd to it. But the fancy bi here is that if we hit back on the browser we will then be brought back to the page previous simulating a multi page site.

# 21.4.4

Here we met the link feature of react-router. First we went into the header and updated it to import the link and use it like this.

import React from "react";
import { Link } from "react-router-dom";

const Header = () => {
return (
<header className="bg-secondary mb-4 py-2 flex-row align-center">
<div className="container flex-row justify-space-between-lg justify-center align-center">
<Link to="/">
<h1>Deep Thoughts</h1>
</Link>

        <nav className="text-center">
          <Link to="/login">Login</Link>
          <Link to="/signup">Signup</Link>
        </nav>
      </div>
    </header>

);
};

export default Header;

Here we added a login and a signup page and linked out to them using the iported variable. Then we went into ThoughtList and got the bones for the Links set up there like this.

import React from "react";
import { Link } from "react-router-dom";

const ThoughtList = ({ thoughts, title }) => {
if (!thoughts.length) {
return <h3>No Thoughts Yet</h3>;
}

return (
<div>
<h3>{title}</h3>
{thoughts &&
thoughts.map((thought) => (
<div key={thought._id} className="card mb-3">
<p className="card-header">
<Link
to={`/profile/${thought.username}`}
style={{ fontWeight: 700 }}
className="text-light" >
{thought.username}
</Link>{" "}
thought on {thought.createdAt}
</p>
<div className="card-body">
<Link to={`/thought/${thought._id}`}>
<p>{thought.thoughtText}</p>
<p className="mb-0">
Reactions: {thought.reactionCount} || Click to{" "}
{thought.reactionCount ? "see" : "start"} the discussion!
</p>
</Link>
</div>
</div>
))}
</div>
);
};

export default ThoughtList;

Next we had to go update the app.js to allow links like this.

<Route
path="/profile/:username?"
element={<Profile />}
/>
<Route
path="/thought/:id"
element={<SingleThought />}
/>

Here we added the variables to the path so when we click it the id or username will show up top in the url. Finally we went into singThought to pull the id from the url with useParams like this.

import React from "react";
import { useParams } from "react-router-dom";

const SingleThought = (props) => {
const { id: thoughtId } = useParams();
console.log("they made me do it", thoughtId);
return (
<div>
<div className="card mb-3">
<p className="card-header">
<span style={{ fontWeight: 700 }} className="text-light">
Username
</span>{" "}
thought on createdAt
</p>
<div className="card-body">
<p>Thought Text</p>
</div>
</div>
</div>
);
};

export default SingleThought;

As of right now we are only console.logging it but that will change in the future.
