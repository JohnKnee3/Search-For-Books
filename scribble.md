# 21.1.3

Set up the base files from the module. Ran npm i and npm run seed. May need to go back and run mongod if the seed didn't run properly. At a glance in the console.log it looks like it did.

# 21.1.4

We set up our first query. We essentially learned that GraphQL calls all GETs query and all PUT, POST, and DELETEs mutations. We created a new folder called schema and added the index.js like this.

const typeDefs = require("./typeDefs");
const resolvers = require("./resolvers");

module.exports = { typeDefs, resolvers };

To require the first file we need called typeDefs like this.

// import the gql tagged template function
const { gql } = require("apollo-server-express");

// create our typeDefs
const typeDefs = gql` type Query { helloWorld: String }`;
// export the typeDefs
module.exports = typeDefs;

This defines what we are looking for and where we can find it. Then we set up the resolvers to preform this like this.

const resolvers = {
Query: {
helloWorld: () => {
return "Hello world!";
},
},
};

module.exports = resolvers;

Here we are running the helloWrold() called in the type Query object and returning a string that says "Hello World". Then we went into server.js and added a ton of things that basically required graphQL apollo to run. Lastly we ran npm run watch to fire the package.json script that takes us to a browser that looks like GraphQL's version of insomnia and tested the the query.

# 21.1.5

Here we did our first test to grab all thoughts like this in typeDef.

type Thought {
\_id: ID
thoughtText: String
createdAt: String
username: String
reactionCount: Int
}

type Query {
thoughts: [Thought]
}

This creates the thoughts array and then defins what it will grab. The we slid into resolvers.js and added this.

const resolvers = {
Query: {
thoughts: async () => {
return Thought.find().sort({ createdAt: -1 });
}
}
};

Which perfoms a find query to grab all thoughts and sorts them by created at. Up top we required the models and then juped into the graphql browser. In there we typed this..

query {
thoughts {
\_id
username
thoughtText
createdAt
}
}

This went through thoughts and grabbed everyting we defined in the object. Also we can remove or add anything from lines 43-47 to change what is shown because that is where we dfined them. Next we brought in the ability to search by user by passing in a parameter into the thoughts typeDef like this.

type Query {
thoughts(username: String): [Thought]
}

and then went into the resolver.js to use it here like this.

thoughts: async (parent, { username }) => {
const params = username ? { username } : {};
return Thought.find(params).sort({ createdAt: -1 });
},

This is saying if username then params = {username} else params = {}. This makes it so we can sort by indvidual user by going into the graphql browser and typing this.

query {
thoughts (username: "Domenica.OConnell") {
\_id
username
thoughtText
createdAt
}
}

Domenica.OConnell is a random user generated by the program. Lastly we added the ability to grab reaction by simply adding this to typeDef.

const typeDefs = gql`

type Thought {
\_id: ID
thoughtText: String
createdAt: String
username: String
reactionCount: Int
reactions: [Reaction]
}

type Reaction {
\_id: ID
reactionBody: String
createdAt: String
username: String
}

type Query {
thoughts(username: String): [Thought]
}
`;

Then we went back into the graphql browser and added this to grab all reactions and thoughts.

query {
thoughts {
\_id
username
thoughtText
reactions {
\_id
createdAt
username
reactionBody
}
}
}

# 21.1.6

Here we quickly added the new User type and updated the query to search by all users and one user and all thoughts and one thought like this.

type Query {
users: [User]
user(username: String!): User
thoughts(username: String): [Thought]
thought(\_id: ID!): Thought
}

type User {
\_id: ID
username: String
email: String
friendCount: Int
thoughts: [Thought]
friends: [User]
}

The rest was testing the querys and basically setting up mega querys to grab everthing and then collapsing the data to parse through what you want all in graphql. The last thing we did was practice sending in a variable through graphQL as well. I saved both of these moving forward as I think they will remain useful. There is a ton of data here so coming back reading this may be helpful in terms of understandin graphQL.

# 21.2.3

We added the ability for a user to create an account and log in. First in typeDefs.js we added this to accept mutations.

type Mutation {
login(email: String!, password: String!): User
addUser(username: String!, email: String!, password: String!): User
}

Then we went into resolvers.s and added this to create the ability to make a user.

addUser: async (parent, args) => {
const user = await User.create(args);

return user;
}

This accepts the username, password and email and uses this info to make an account. Then in graphQL we added this.

mutation {
addUser(username:"tester", password:"test12345", email:"test@test.com") {
\_id
username
email
}
}

Then we switched it to variables.

mutation addUser($username: String!, $password: String!, $email: String!) {
addUser(username: $username, password: $password, email: $email) {
\_id
username
email
}
}

and passed in this.

{
"username": "tester2",
"password": "test12345",
"email": "test2@test.com"
}

Both of these created users just the second one is closer to what it will acutally look like once we have the front end hooked up. Finally up top we added this.

const { AuthenticationError } = require('apollo-server-express');

and then this in the login section.

login: async (parent, { email, password }) => {
const user = await User.findOne({ email });

if (!user) {
throw new AuthenticationError('Incorrect credentials');
}

const correctPw = await user.isCorrectPassword(password);

if (!correctPw) {
throw new AuthenticationError('Incorrect credentials');
}

return user;
}

to make sure we get tossed an error if the log in was not valid. Then using variables we went into graphQL and used.

mutation login($email: String!, $password: String!) {
login(email: $email, password: $password) {
\_id
username
email
}
}

and this

{
"email": "test2@test.com",
"password": "test12345"
}

to log in as an existing user.
