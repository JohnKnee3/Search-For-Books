# 21.1.3

Set up the base files from the module. Ran npm i and npm run seed. May need to go back and run mongod if the seed didn't run properly. At a glance in the console.log it looks like it did.

# 21.1.4

We set up our first query. We essentially learned that GraphQL calls all GETs query and all PUT, POST, and DELETEs mutations. We created a new folder called schema and added the index.js like this.

const typeDefs = require("./typeDefs");
const resolvers = require("./resolvers");

module.exports = { typeDefs, resolvers };

To require the first file we need called typeDefs like this.

// import the gql tagged template function
const { gql } = require("apollo-server-express");

// create our typeDefs
const typeDefs = gql` type Query { helloWorld: String }`;
// export the typeDefs
module.exports = typeDefs;

This defines what we are looking for and where we can find it. Then we set up the resolvers to preform this like this.

const resolvers = {
Query: {
helloWorld: () => {
return "Hello world!";
},
},
};

module.exports = resolvers;

Here we are running the helloWrold() called in the type Query object and returning a string that says "Hello World". Then we went into server.js and added a ton of things that basically required graphQL apollo to run. Lastly we ran npm run watch to fire the package.json script that takes us to a browser that looks like GraphQL's version of insomnia and tested the the query.

# 21.1.5

Here we did our first test to grab all thoughts like this in typeDef.

type Thought {
\_id: ID
thoughtText: String
createdAt: String
username: String
reactionCount: Int
}

type Query {
thoughts: [Thought]
}

This creates the thoughts array and then defins what it will grab. The we slid into resolvers.js and added this.

const resolvers = {
Query: {
thoughts: async () => {
return Thought.find().sort({ createdAt: -1 });
}
}
};

Which perfoms a find query to grab all thoughts and sorts them by created at. Up top we required the models and then juped into the graphql browser. In there we typed this..

query {
thoughts {
\_id
username
thoughtText
createdAt
}
}

This went through thoughts and grabbed everyting we defined in the object. Also we can remove or add anything from lines 43-47 to change what is shown because that is where we dfined them. Next we brought in the ability to search by user by passing in a parameter into the thoughts typeDef like this.

type Query {
thoughts(username: String): [Thought]
}

and then went into the resolver.js to use it here like this.

thoughts: async (parent, { username }) => {
const params = username ? { username } : {};
return Thought.find(params).sort({ createdAt: -1 });
},

This is saying if username then params = {username} else params = {}. This makes it so we can sort by indvidual user by going into the graphql browser and typing this.

query {
thoughts (username: "Domenica.OConnell") {
\_id
username
thoughtText
createdAt
}
}

Domenica.OConnell is a random user generated by the program. Lastly we added the ability to grab reaction by simply adding this to typeDef.

const typeDefs = gql`

type Thought {
\_id: ID
thoughtText: String
createdAt: String
username: String
reactionCount: Int
reactions: [Reaction]
}

type Reaction {
\_id: ID
reactionBody: String
createdAt: String
username: String
}

type Query {
thoughts(username: String): [Thought]
}
`;

Then we went back into the graphql browser and added this to grab all reactions and thoughts.

query {
thoughts {
\_id
username
thoughtText
reactions {
\_id
createdAt
username
reactionBody
}
}
}

# 21.1.6

Here we quickly added the new User type and updated the query to search by all users and one user and all thoughts and one thought like this.

type Query {
users: [User]
user(username: String!): User
thoughts(username: String): [Thought]
thought(\_id: ID!): Thought
}

type User {
\_id: ID
username: String
email: String
friendCount: Int
thoughts: [Thought]
friends: [User]
}

The rest was testing the querys and basically setting up mega querys to grab everthing and then collapsing the data to parse through what you want all in graphql. The last thing we did was practice sending in a variable through graphQL as well. I saved both of these moving forward as I think they will remain useful. There is a ton of data here so coming back reading this may be helpful in terms of understandin graphQL.
